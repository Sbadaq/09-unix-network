# 第五章 posix消息队列 

## 5.1 概述
posix消息队列是linux系统提供的一种消息传递机制，消息队列是先进先出（FIFO）的，消息队列中的消息是可读可写的，消息队列中的消息是可共享的，消息队列中的消息是可持久化的。
消息队列的创建和删除，以及消息的读写都是原子操作，所以消息队列是线程安全的。
posix消息队列和管道的区别：
 
消息队列和管道都是用于进程间通信的机制，但存在一些区别。
- 管道是字节流，消息队列是字节块；
- 管道是半双工的，只能用于读写；
消息队列的创建和删除，以及消息的读写都是原子操作，所以消息队列是线程安全的。

消息队列具有 随内核的一致性，这一点与fifo不同，fifo是随文件系统的一致性。
## 5.2 posix消息队列的创建
mq_open函数用于创建或打开一个消息队列。
mq_clo函数用于关闭一个消息队列。
mq_unlink函数用于删除一个消息队列。

## 5.3 posix消息队列的四个属性
mq_getattr函数用于获取消息队列的属性。
mq_setattr函数用于设置消息队列的属性。

## 5.4 mq_send函数和mq_receive函数
mq_send函数用于向消息队列中发送消息。
mq_receive函数用于从消息队列中接收消息。
mq_send函数和mq_receive函数都是原子操作，所以它们是线程安全的。

## 5.5 消息队列 的限制
消息队列的最大长度是1MB，消息队列的最大数量是1024。
mq_mqxmsgs函数用于获取消息队列的最大数量。
mq_msgsize 函数用于获取消息队列的最大长度。

## 5.6 mq_notify函数
mq_notify函数用于注册一个信号，当消息队列中有消息时，会发送这个信号。
mq_notify函数是异步的，所以它可以在消息队列中有消息时，立即发送信号。
mq_notify函数的参数是信号和消息队列。

### 5.6.1 简单信号通知
这个例子是先注册一个信号，SIGUSR1信号。当消息队列中有消息时，会发送这个信号。
处理信号的函数是sig_usr函数。
```
    signal(SIGUSR1, sig_usr);
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIGUSR1;
    mq_notify(mqd, &sev);
```
这个例子的关键问题是 ，信号和处理是自导自演的。
实际上不可能注册和处理都是在一个程序中完成的。
 
### 5.6.2 异步信号安全函数
### 5.6.3 信号通知
避免从信号处理程序中调用任何函数 的方法之一是：让处理程序仅设置一个全局标志，
由某信线程检查这个标志，以确定何时收到消息。
这个例子中 我们使用了3个信号集 sigset_t 
```
 struct sigevent {
                  int             sigev_notify; /* Notification type */
                  int             sigev_signo;  /* Signal number */
                  union sigval    sigev_value;  /* Signal value */
                  void          (*sigev_notify_function)(union sigval);
                                                /* Notification function */
                  pthread_attr_t *sigev_notify_attributes;
                                                /* Notification attributes */
              };
```
The use of sigprocmask() is unspecified in a multithreaded process; see pthread_sigmask(3).

### 5.6.4 使用非阻塞的mq_receive信号通知
打开队列 就是创建一个非阻塞的队列，接收数据时判断EAGAIN ；
在这段代码中，sigprocmask(SIG_BLOCK, &newmask, &oldmask); 这一行代码将 SIGUSR1 信号添加到信号掩码中，从而阻塞了该信号。

```
mq = mq_open(argv[1],O_RDONLY|O_NONBLOCK);
sigprocmask(SIG_BLOCK, &newmask, &oldmask);
if(errno != EAGAIN)
{
    printf("mq_receive error\n" );

}else{
    // mq_notify(mq, &sev);
    printf("mq_receive EAGAIN,this means read no data more.\n");
}

 sigprocmask(SIG_UNBLOCK, &newmask, NULL);
```
`为什么读完消息再次把队列打开（why ?? `

**阻塞信号的原因**
- 在这段代码中，sigprocmask(SIG_BLOCK, &newmask, &oldmask); 这一行代码将 SIGUSR1 信号添加到信号掩码中，从而阻塞了该信号。
- 阻塞信号的主要目的是为了确保在处理信号相关的操作时，不会被其他信号干扰。例如，在 sigsuspend 函数调用期间，程序会暂停执行，等待信号的到来。如果此时不阻塞 SIGUSR1 信号，可能会导致信号被多次处理或处理顺序混乱。
**处理完信号后解除阻塞的原因**
-当程序处理完 SIGUSR1 信号后，需要再次调用 sigprocmask(SIG_UNBLOCK, &newmask, NULL); 来解除对 SIGUSR1 信号的阻塞。
-这是因为如果不解除阻塞，SIGUSR1 信号将一直被屏蔽，即使后续有新的 SIGUSR1 信号到达，也不会被处理。通过解除阻塞，程序可以继续正常接收和处理 SIGUSR1 信号。

### 5.6.5 使用sigwait 代替信号处理程序的信号通知
运用 sigprocmask(SIG_BLOCK, &newmask, NULL); 把 SIGUSR1 信号给阻塞了，这是为了让 sigwait 函数可以等待这个信号。sigwait 函数自身就会阻塞线程，直至接收到指定信号，当接收到信号之后，它会把信号从信号掩码里移除，并且返回接收到的信号编号。
当 sigwait 接收到 SIGUSR1 信号之后，这个信号就已经不在信号掩码里了，也就是处于未阻塞状态。
这时要再次调用  mq_notify(mq, &sev); 就是重新注册消息队列通知的操作。在处理完当前消息队列里的消息之后，再次调用 mq_notify 函数，使得消息队列可以在下次有新消息到来时，继续通过发送 SIGUSR1 信号来通知程序。

### 5.6.6 使用select的posix消息队列 
### 5.6.7 启动线程 

## 5.7 posix 实时信号
signal_rt
如今多数 Unix 系统支持 Posix 可靠信号，部分新系统逐步提供 Posix 实时信号。
- Posix 信号分类
** 实时信号：值在 SIGRTMIN 和 SIGRTMAX 之间（含两端），Posix 要求至少提供 RTSIG_MAX 种实时信号，其最小值为 8 。如 Solaris 2.6 上实时信号值为 38 - 45 ；Digital Unix 4.0B 上为 33 - 48 ，且两者都将 SIGRTMIN 和 SIGRTMAX 定义为可通过 sysconf 宏修改的值。
** 其他信号：如 SIGALRM、SIGINT、SIGKILL 等

这段代码演示了实时信号（Real-Time Signals）的发送、阻塞和处理机制，涉及父子进程间的同步与异步通信。以下是对代码的分析及执行流程的解释：

### 关键点分析
1. **实时信号范围**：
   - 使用 `SIGRTMIN` 和 `SIGRTMAX` 确定实时信号的范围，通常为 `34` 到 `64`（依系统不同可能变化）。

2. **子进程流程**：
   - **阻塞信号**：子进程通过 `sigprocmask` 阻塞三个最高实时信号（如 `SIGRTMAX`, `SIGRTMAX-1`, `SIGRTMAX-2`），防止在处理前接收。
   - **注册处理函数**：使用 `sigaction` 注册 `sig_rt` 处理函数，设置 `SA_SIGINFO` 标志以传递额外信息。
   - **休眠与解除阻塞**：休眠6秒后解除信号阻塞，再休眠3秒后退出。解除阻塞后，挂起的信号会被处理。

3. **父进程流程**：
   - 休眠3秒后，通过 `sigqueue` 向子进程发送9个信号（每个目标信号3次），携带递增的整数值。
   - 等待子进程结束。

4. **信号处理**：
   - 处理函数 `sig_rt` 打印接收到的信号编号及其携带的值。实时信号支持排队，确保所有信号按发送顺序处理。

### 执行流程
1. **父进程创建子进程**：
   - 子进程初始化信号集，阻塞三个实时信号，注册处理函数，进入6秒休眠。
   - 父进程休眠3秒后开始发送信号。

2. **信号发送与接收**：
   - 父进程在子进程阻塞期间发送所有信号，信号被挂起。
   - 子进程休眠结束后解除阻塞，触发信号处理。此时所有挂起的信号按顺序处理，打印对应值。

3. **输出结果**：
   - 每个目标信号（如31、30、29）按三次发送顺序处理，携带值依次递增（如31→41→51，30→40→50等）。

### 示例输出
```
SIGRTMIN = 34, SIGRTMAX = 64
sent signal 64, val = 64
sent signal 64, val = 74
sent signal 64, val = 84
sent signal 63, val = 63
sent signal 63, val = 73
sent signal 63, val = 83
sent signal 62, val = 62
sent signal 62, val = 72
sent signal 62, val = 82
caught signal 64, val = 64
caught signal 64, val = 74
caught signal 64, val = 84
caught signal 63, val = 63
caught signal 63, val = 73
caught signal 63, val = 83
caught signal 62, val = 62
caught signal 62, val = 72
caught signal 62, val = 82
```

### 潜在问题与改进
- **信号阻塞时间**：子进程长时间阻塞可能导致父进程发送的信号积压，但实时信号排队机制确保无丢失。
- **系统调用重启**：`SA_RESTART` 可能导致 `sleep` 自动重启，但在此示例中不影响最终结果。
- **可移植性**：`SA_INTERRUPT` 和 `SA_RESTART` 的条件编译需根据系统调整，但对实时信号影响有限。

此代码有效展示了实时信号的生命周期管理及进程间通信机制。


---
是的，你的理解基本正确。信号确实分为**实时信号（Real-Time Signals）**和**非实时信号（Standard Signals）**，它们的底层行为和设计目的有显著差异。代码中强调使用实时信号，正是因为其特性是实现该功能的关键。以下是详细解释：

---

### **1. 信号的分类**
#### **非实时信号（Standard Signals）**
- **范围**：通常为 `1~31`（如 `SIGINT`=2, `SIGKILL`=9, `SIGTERM`=15）。
- **特性**：
  - **不可靠（Unreliable）**：如果同一信号多次发送，内核可能合并为一个（信号丢失）。
  - **无序性**：信号可能乱序到达（例如后发送的信号先被处理）。
  - **无附加数据**：只能通过信号编号传递信息，无法携带额外数据。
  - **默认行为**：部分信号会终止进程（如 `SIGKILL` 不可捕获）。

#### **实时信号（Real-Time Signals）**
- **范围**：`SIGRTMIN` 到 `SIGRTMAX`（通常是 `34~64`，具体依赖系统）。
- **特性**：
  - **可靠（Reliable）**：所有信号都会被排队，不会丢失。
  - **有序性**：按发送顺序处理。
  - **携带数据**：可通过 `sigval` 传递整型或指针数据（如代码中的 `value.sival_int`）。
  - **可抢占性**：高优先级实时信号可能中断低优先级信号处理。

---

### **2. 为什么代码必须使用实时信号？**
#### **场景需求**
代码中父进程向子进程发送了 **9 个信号**（3 个信号各发送 3 次），子进程需要在解除阻塞后按发送顺序处理所有信号。  
如果使用非实时信号：
- 同一信号多次发送会被合并（例如 3 次 `SIGUSR1` 只会触发一次处理）。
- 无法保证信号处理顺序（可能乱序）。
- 无法携带额外数据（如代码中的 `sival_int`）。

而实时信号完美满足需求：
- 所有 9 个信号均被接收并处理。
- 按发送顺序依次处理（先发送的 `SIGRTMAX`，后发送的 `SIGRTMAX-2`）。
- 每个信号携带的 `sival_int` 值正确（如 `64→74→84` 对应三次发送）。

---

### **3. 信号的“尽力而为”是什么意思？**
- **非实时信号的“尽力而为”**：  
  内核不保证非实时信号的可靠传递。例如：
  - 如果进程正在处理另一个信号，新信号可能被丢弃。
  - 如果同一信号多次发送，内核可能仅保留一个实例。
  - 这种“尽力而为”的设计是为了避免复杂的内存管理和性能开销。

- **实时信号的严格性**：  
  实时信号要求内核必须严格处理所有信号，且按顺序排队。这种严格性牺牲了部分性能，但保证了可靠性，适用于需要精确控制的场景（如进程间协调、任务调度）。

---

### **4. 代码中的关键体现**
#### **实时信号的排队与顺序性**
```c
// 父进程发送 3 次 SIGRTMAX，3 次 SIGRTMAX-1，3 次 SIGRTMAX-2
for (i = SIGRTMAX; i >= SIGRTMAX - 2; i--) {
    for (j = 0; j < 3; j++) {
        value.sival_int = i + j * 10;
        sigqueue(pid, i, value);  // 每个信号携带不同的值
    }
}
```
子进程解除阻塞后，输出的顺序和值严格对应发送顺序：
```
caught signal 64, val = 64   → 第一次发送的 SIGRTMAX
caught signal 64, val = 74   → 第二次发送的 SIGRTMAX
caught signal 64, val = 84   → 第三次发送的 SIGRTMAX
caught signal 63, val = 63   → 第一次发送的 SIGRTMAX-1
...
```

#### **非实时信号的缺陷**
如果替换为非实时信号（如 `SIGUSR1`）：
- 父进程发送的 9 个信号可能被合并为 3 次处理（每个信号只保留一个实例）。
- 处理顺序不确定（可能先处理 `SIGUSR1` 的最后一次发送）。
- 无法通过 `sigval` 传递 `val` 值。

---

### **5. 总结**
- **实时信号**：  
  适用于需要**可靠传递、顺序处理、携带数据**的场景（如任务调度、事件通知）。  
  代价是内核需要维护信号队列，占用更多资源。

- **非实时信号**：  
  适用于**简单通知**（如终止进程），设计上追求简单和高效，但可靠性不足。

代码中强调实时信号，是因为它依赖以下特性：
1. **信号不丢失**（确保 9 个信号全部处理）。
2. **顺序性**（按发送顺序处理）。
3. **携带数据**（通过 `sival_int` 传递值）。

如果使用非实时信号，代码的行为将不可预测，无法达到预期效果。


## 5.8 使用内存映射io实现posix消息队列
第七章介绍 互斥锁和条件变量，第13章介绍内存映射io。可以先阅读过这2章再阅读本章。

### 5.8.1 mq_open函数
这部分内容围绕使用内存映射 I/O 实现 Posix 消息队列展开，主要涵盖以下关键要点：

### 数据结构定义
 - **`mq_atr` 结构**：定义了消息队列的相关属性，像标志（如非阻塞标志 `O_NONBLOCK`  ）、允许的最大消息数（`mq_maxmsg` ）、消息最大字节数（`mq_msgsize` ）以及当前队列中的消息数（`mq_curmsgs` ） 。这些属性用于描述和管理消息队列的基本特征和状态。
 - **`mq_hdr` 结构**：位于映射文件开头，包含针对每个队列的所有信息。其中，队列相关信息如队列属性（`mq_atr` 结构相关内容 ）、消息索引（`mq_head` 表示消息链表起始索引、`mq_free` 表示空闲消息链表起始索引 ） ，还涉及到线程相关的等待索引（`mq_wait` ）、进程 ID（`mq_pid` ）、消息事件（`mq_event` ）以及互斥锁（`mq_lock` ）和条件变量（`mq_wait` ）等，用于协调多线程对消息队列的访问。
 - **`msg_hdr` 结构**：处在映射文件中每个消息的开头，用于管理单个消息。它包含指向下一个消息的索引（`msg_next` ） 、消息数据实际长度（`msg_len` ）和消息优先级（`msg_prio` ） ，通过这些信息将消息组织成链表形式。
 - **`mq_info` 结构**：每次打开队列时，`mq_open` 会动态分配该结构，由 `mq_close` 释放 。它的成员 `mqi_hdr` 指向映射文件起始地址，`mqi_magic` 用于结构初始化验证（值为 `MQI_MAGIC`  ），`mqi_flags` 保存当前队列本次打开实例的非阻塞标志等信息，是管理单个消息队列打开实例的核心结构。 

### `mq_open` 函数实现
 - **创建新消息队列**：当指定 `O_CREAT` 标志且消息队列不存在时，按调用者指定名字创建普通文件。会处理竞争状态，通过 `O_EXCL` 标志检测文件是否已存在，若 `open` 返回 `EEXIST` 错误且指定了 `O_EXCL` ，表示文件已存在，不进行初始化；否则创建并初始化。同时会检查调用者传入的消息队列属性（`mq_maxmsg` 和 `mq_msgsize` ）是否为正数。
 - **打开已存在消息队列**：在未指定 `O_CREAT` 标志或指定但队列已存在时，打开含消息队列信息的文件，用 `mmap` 将文件内存映射到当前进程地址空间。在此过程中要等待消息队列初始化完成，通过检查文件权限（`stat` 结构的 `st_mode` 成员 ）判断初始化状态，处理可能出现的竞争状态。
 - **函数内部操作流程**
    - **设置文件大小**：计算每个消息大小并向上舍入到长整数倍数，结合 `mq_hdr` 结构和消息头分配空间，确定文件大小。
    - **内存映射文件**：调用 `mmap` 将文件映射到内存，以便后续操作。
    - **分配和初始化 `mq_info` 结构**：为每次 `mq_open` 调用分配并初始化 `mq_info` 结构，设置相关成员值。
    - **初始化 `mq_hdr` 结构**：初始化消息链表头（`mgh_head` ）为 0 ，将队列中所有消息加入空闲链表（`mgh_free` ） 。
    - **初始化互斥锁和条件变量**：以 `PTHREAD_PROCESS_SHARED` 属性初始化互斥锁和条件变量，用于多进程间同步。
    - **处理错误**：检测到错误时跳转到 `err` 标号处，注意保证错误处理函数不影响返回的 `errno` 值，进行清理并返回错误值。

### 编程思想与方法总结
 - **内存映射 I/O 运用**：通过 `mmap` 函数将文件映射到内存，使对文件的操作如同对内存操作，提高消息队列数据访问和处理效率，减少传统文件 I/O 操作开销。
 - **多进程同步机制**：利用互斥锁（`pthread_mutex_t` ）和条件变量（`pthread_cond_t` ） ，并设置 `PTHREAD_PROCESS_SHARED` 属性，实现多进程环境下对消息队列的安全访问和同步操作，避免数据竞争等问题。
 - **错误处理与健壮性**：细致处理各种可能错误情况，如文件打开错误、内存映射失败等，合理设置 `errno` 并进行资源清理，保证程序在异常情况下的稳定性和可靠性。
 - **竞争状态处理**：在创建和打开消息队列过程中，充分考虑多进程或多线程并发操作时的竞争状态，通过文件权限检查、`O_EXCL` 标志等手段进行检测和处理，确保消息队列初始化和操作的正确性 。 

### 5.8.2 mq_close函数
### 5.8.3 mq_unlink函数
### 5.8.4 mq_getattr函数
### 5.8.5 mq_setattr函数
### 5.8.6 mq_notify函数
### 5.8.7 mq_send函数
### 5.8.8 mq_receive函数


## 5.4 posix消息队列的消息读写
mq_send函数用于向消息队列中发送消息。
mq_receive函数用于从消息队列中接收消息。

## 5.5 posix消息队列的结构体

## 5.6 posix消息队列的通知
my_notify函数用于设置消息队列的通知。
